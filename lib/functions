# ============================================================================
# VARIABLES
# ----------------------------------------------------------------------------

SCRIPT_TITLE="arch-installer"
SCRIPT_VERSION="0.0.1"

# prompt
PS3="${BGREEN}> ${RESET}"

# ============================================================================
# LIBS
# ----------------------------------------------------------------------------

[[ -e ./lib/colors ]] && source ./lib/colors
[[ -e ./lib/commons ]] && source ./lib/commons || { echo "O arquivo commons está faltando."; exit 1; }

# ============================================================================
# TEST FUNCTIONS
# ----------------------------------------------------------------------------

_check_archlinux() {
  _print_action "Verificando" "Arch Linux Release"
  if [[ -e "/etc/arch-release" ]]; then
    _print_done
  else
    _print_error
    echo
    _print_warning "O script deve ser executado no ${BYELLOW}Arch Linux${RESET}."
    _print_exit
    exit 1
  fi
}

_check_uefimode() {
  _print_action "Verificando" "modo UEFI"
  if [[ -d "/sys/firmware/efi/" ]]; then
    _print_done
  else
    _print_error
    echo
    _print_warning "O script deve ser executado em modo ${BYELLOW}UEFI${RESET}."
    _print_exit
    exit 1
  fi
}

_check_connection() {
  _connection_test() {
    ping -q -w 1 -c 1 "$(ip r | grep default | awk 'NR==1 {print $3}')" &> /dev/null && return 1 || return 0
  }
  _print_action "Verificando" "conexão com a internet"
  if ! _connection_test; then
    _print_done
  else
    _print_error
    echo
    _print_warning "É necessário uma conexão com a internet para executar o script."
    _print_exit
    exit 1
  fi
}

_check_root() {
  _print_action "Verificando" "usuário root"
  if [[ $(id -u) -eq 0 ]]; then
    _print_done
  else
    _print_error
    echo
    _print_warning "O script deve ser executado com usuário 'root'."
    _print_exit
    exit 1
  fi
}

_check_pacman_blocked() {
  _print_action "Verificando" "bloqueio do Pacman"
  if [[ ! -f "/var/lib/pacman/db.lck" ]]; then
    _print_done
  else_select_disk
    _print_error
    echo
    _print_warning "O Pacman está bloqueado. Se não estiver sendo executado, remova o arquivo /var/lib/pacman/db.lck."
    _print_exit
    exit 1
  fi
}

# ============================================================================
# BASIC FUNCTIONS
# ----------------------------------------------------------------------------

_package_install() { # Install pacman packages
  for PKG in $1; do
    _print_action "Instalando" "${PKG}"
    if ! _is_package_installed "${PKG}"; then
      pacman -S --noconfirm --needed "${PKG}" &> /dev/null & PID=$!; _progress $PID
    else
      tput rc
      echo -e "${YELLOW}existe${RESET}"
    fi
  done
}

_pacstrap_install() { # Install pacstrap packages
  for PKG in $1; do
    _print_action "Instalando" "${PKG}"
    pacstrap "${ROOT_MOUNTPOINT}" "${PKG}" &> /dev/null & PID=$!; _progress $PID
  done
}

_is_package_installed() {
  for PKG in $1; do
    pacman -Q "$PKG" &> /dev/null && return 0;
  done
  return 1
}

_set_font() {
  _package_install "terminus-font"
  _print_action "Configurando" "fonte do tty"
  setfont ter-116b &> /dev/null & PID=$!; _progress $PID
}

# ============================================================================
# MAIN FUNCTIONS
# ----------------------------------------------------------------------------

_select_disk() {
  local title="SELECIONAR DISCO DE INSTALAÇÃO"
  _print_title ${title}
  items=$(lsblk -d -p -n -l -o NAME,SIZE -e 7,11)
  DISKS_LIST=()
  SAVEIFS=$IFS
  IFS=$'\n'
  for item in ${items}; do
    DISKS_LIST+=("${item}")
  done
  IFS=$SAVEIFS
  _print_select "Selecione um disco:"
  select DISK in "${DISKS_LIST[@]}"; do
    if _contains_element "${DISK}" "${DISKS_LIST[@]}"; then
      break
    else
      _invalid_option
    fi
  done
  INSTALL_DISK=${DISK%%\ *}
  echo
  _print_line
  _read_input_option "Editar a tabela de partições? [s/N]: "
  if [[ ${OPTION,,} == "s" ]]; then
    cfdisk "${INSTALL_DISK}"
    _print_title ${title}
    echo
    _print_item "Disco selecionado" "${INSTALL_DISK}"
    _pause_function
  fi
}

_format_partitions() {
  local title="FORMATAR E MONTAR PARTIÇÕES"
  _format_root_partition() {
    _print_title ${title}
    _print_select "Selecione a partição ${BYELLOW}ROOT${RESET}${BCYAN}:${RESET}"
    _print_danger "Todos os dados nesta partição serão deletados!"
    echo
    _umount_partitions
    # Luks volumes open?
    items=$(lsblk | awk '{print $6}' | grep 'crypt')
    LUKS_VOLUMES=()
    SAVEIFS=$IFS
    IFS=$'\n'
    for item in ${items}; do
      LUKS_VOLUMES+=("${item}")
    done
    IFS=$SAVEIFS
    if [[ ! ${#LUKS_VOLUMES[@]} -eq 0 ]]; then
      items=$(dmsetup ls --target crypt | awk '{print $1}')
      LUKS_OPEN=()
      SAVEIFS=$IFS
      IFS=$'\n'
      for item in ${items}; do
        LUKS_OPEN+=("${item}")
      done
      IFS=$SAVEIFS
      for item in "${LUKS_OPEN[@]}"; do
        cryptsetup close /dev/mapper/"${item}"
      done
    fi
    select PARTITION in "${PARTITIONS_LIST[@]}"; do
      if _contains_element "${PARTITION}" "${PARTITIONS_LIST[@]}"; then
        PARTITION_NUMBER=$((REPLY -1))
        ROOT_PARTITION="$PARTITION"
        ROOT_DEVICE="$PARTITION"
        LUKS=0
        break;
      else
        _invalid_option
      fi
    done
    echo
    _read_input_option "Deseja criptografar a partição? [s/N]: "
    if [[ ${OPTION,,} == "s" ]]; then
      echo
      _read_input_option "${BRED}Tem certeza? [s/N]: ${RESET}"
      if [[ ${OPTION,,} == "s" ]]; then
        _print_subtitle "luksFormat"
        cryptsetup luksFormat "$ROOT_PARTITION" && _print_subtitle "luksOpen" && cryptsetup open "${ROOT_PARTITION}" "${CRYPT_NAME}" && LUKS=1 && ROOT_DEVICE="/dev/mapper/${CRYPT_NAME}"
      fi
    fi
    echo
    _print_action "Formatando" "${ROOT_DEVICE}"
    mkfs.btrfs -f -L Archlinux "${ROOT_DEVICE}" &> /dev/null & PID=$!; _progress $PID
    mount "${ROOT_DEVICE}" "${ROOT_MOUNTPOINT}" &> /dev/null
    _print_action "Criando" "subvolume ${MAGENTA}@${RESET}"
    btrfs su cr ${ROOT_MOUNTPOINT}/@ &> /dev/null & PID=$!; _progress $PID
    _print_action "Criando" "subvolume ${MAGENTA}@home${RESET}"
    btrfs su cr ${ROOT_MOUNTPOINT}/@home &> /dev/null & PID=$!; _progress $PID
    _print_action "Criando" "subvolume ${MAGENTA}@log${RESET}"
    btrfs su cr ${ROOT_MOUNTPOINT}/@log &> /dev/null & PID=$!; _progress $PID
    _print_action "Criando" "subvolume ${MAGENTA}@pkg${RESET}"
    btrfs su cr ${ROOT_MOUNTPOINT}/@pkg &> /dev/null & PID=$!; _progress $PID
    _print_action "Criando" "subvolume ${MAGENTA}@snapshots${RESET}"
    btrfs su cr ${ROOT_MOUNTPOINT}/@snapshots &> /dev/null & PID=$!; _progress $PID
    _umount_partitions
    _print_action "Montando" "${MAGENTA}@${RESET} em /"
    mount -o noatime,compress=zstd,space_cache=v2,ssd,discard=async,subvol=@ "${ROOT_DEVICE}" "${ROOT_MOUNTPOINT}" &> /dev/null & PID=$!; _progress $PID
    mkdir -p "${ROOT_MOUNTPOINT}"/{home,var/cache/pacman/pkg,.snapshots} &> /dev/null
    _print_action "Montando" "${MAGENTA}@home${RESET} em /home"
    mount -o noatime,compress=zstd,space_cache=v2,ssd,discard=async,subvol=@home "${ROOT_DEVICE}" "${ROOT_MOUNTPOINT}"/home &> /dev/null & PID=$!; _progress $PID
    _print_action "Montando" "${MAGENTA}@log${RESET} em /var/log"
    mount -o noatime,compress=zstd,space_cache=v2,ssd,discard=async,subvol=@log "${ROOT_DEVICE}" "${ROOT_MOUNTPOINT}"/home &> /dev/null & PID=$!; _progress $PID
    _print_action "Montando" "${MAGENTA}@pkg${RESET} em /var/cache/pacman/pkg"
    mount -o noatime,compress=zstd,space_cache=v2,ssd,discard=async,subvol=@pkg "${ROOT_DEVICE}" "${ROOT_MOUNTPOINT}"/var/cache/pacman/pkg &> /dev/null & PID=$!; _progress $PID
    _print_action "Montando" "${MAGENTA}@snapshots${RESET} em /.snapshots"
    mount -o noatime,compress=zstd,space_cache=v2,ssd,discard=async,subvol=@snapshots "${ROOT_DEVICE}" "${ROOT_MOUNTPOINT}"/.snapshots &> /dev/null & PID=$!; _progress $PID
    _check_mountpoint "${ROOT_DEVICE}" "${ROOT_MOUNTPOINT}"
    ROOT_UUID=$(blkid -s UUID -o value "${ROOT_PARTITION}")
    _pause_function
  }

  _format_efi_partition() {
    _print_title ${title}
    _print_select "Selecione a partição ${BYELLOW}EFI${RESET}${BCYAN}:${RESET}"
    select PARTITION in "${PARTITIONS_LIST[@]}"; do
      if _contains_element "${PARTITION}" "${PARTITIONS_LIST[@]}"; then
        PARTITION_NUMBER=$((REPLY -1))
        EFI_PARTITION="${PARTITION}"
        break;
      else
        _invalid_option
      fi
    done
    echo
    _read_input_option "Deseja formatar a partição? [s/N]: "
    if [[ ${OPTION,,} == "s" ]]; then
      echo
      _read_input_option "${BRED}Todos os dados serão deletados! Confirma formatar a partição? [s/N]: ${RESET}"
      echo
      if [[ ${OPTION,,} == "s" ]]; then
        _print_action "Formatando" "${EFI_PARTITION}"
        mkfs.fat -F32 "${EFI_PARTITION}" &> /dev/null & PID=$!; _progress $PID
      fi
    fi
    mkdir -p ${ROOT_MOUNTPOINT}${EFI_MOUNTPOINT} &> /dev/null
    _print_action "Mountando" "${EFI_PARTITION} em ${EFI_MOUNTPOINT}"
    mount -t vfat "${EFI_PARTITION}" ${ROOT_MOUNTPOINT}${EFI_MOUNTPOINT} &> /dev/null & PID=$!; _progress $PID
    _check_mountpoint "${EFI_PARTITION}" "${ROOT_MOUNTPOINT}${EFI_MOUNTPOINT}"
  }

  _disable_partition() {
    unset PARTITIONS_LIST["${PARTITION_NUMBER}"]
    PARTITIONS_LIST=("${PARTITIONS_LIST[@]}")
  }

  _check_mountpoint() {
    if mount | grep "$2" &> /dev/null; then
      echo
      _print_info "Partições montadas com sucesso!"
      _disable_partition "$1"
    else
      echo
      _print_warning "As partições não foram montadas com sucesso!"
    fi
  }
  items=$(lsblk -p -l | grep 'part' | awk '{print $1}')
  PARTITIONS_LIST=()
  for item in ${items}; do
    PARTITIONS_LIST+=("${item}")
  done
  _format_root_partition
  _format_efi_partition
  _pause_function
}

_rank_mirrors() {
  _print_subtitle "Espelhos de rede"
  _print_action "Executando" "reflector --score 10 --save /etc/pacman.d/mirrorlist"
  [[ ! -f /etc/pacman.d/mirrorlist.backup ]] && cp /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.backup
  reflector --score 10 --save /etc/pacman.d/mirrorlist &> /dev/null & PID=$!; _progress $PID
  _print_subtitle "Atualizando"
  pacman -Syy
  _pause_function
}

_install_base() {
  local title="INSTALANDO A BASE"
  _print_title ${title}
  echo
  _rank_mirrors
  _print_item "Versão do kernel" "${KERNEL_VERSION}"
  _print_item "Versão do microcode" "${MICROCODE_VERSION}"
  _print_subtitle "Instalando pacotes base"
  _pacstrap_install "base base-devel"
  _pacstrap_install "${KERNEL_VERSION}"
  _pacstrap_install "${KERNEL_VERSION}-headers"
  _pacstrap_install "linux-firmware"
  _pacstrap_install "${MICROCODE_VERSION}"
  _pacstrap_install "btrfs-progs nano"
  _pacstrap_install "networkmanager"

  _print_action "Habilitando" "NetworkManager"
  arch-chroot ${ROOT_MOUNTPOINT} systemctl enable NetworkManager &> /dev/null & PID=$!; _progress $PID
  _pause_function
}

_generate_fstab() {
  _print_title "FSTAB"
  echo
  _print_action "Executando" "genfstab -U ${ROOT_MOUNTPOINT} > ${ROOT_MOUNTPOINT}/etc/fstab"
  genfstab -U ${ROOT_MOUNTPOINT} > ${ROOT_MOUNTPOINT}/etc/fstab & PID=$!; _progress $PID
  echo
  _print_line
  _read_input_option "Editar fstab? [s/N]: "
  if [[ ${OPTION,,} == "s" ]]; then
    nano ${ROOT_MOUNTPOINT}/etc/fstab
  fi
}

_set_timezone() {
  _print_title "CONFIGURANDO O FUSO HORÁRIO"
  _print_item "Timezone" "${TIMEZONE}"
  _print_item "Relógio do Hardware" "${CLOCK_CHOICE}"
  echo
  _print_action "Executando" "timedatectl set-ntp true"
  arch-chroot ${ROOT_MOUNTPOINT} timedatectl set-ntp true &> /dev/null & PID=$!; _progress $PID
  _print_action "Executando" "ln -sf /usr/share/zoneinfo/${TIMEZONE} /etc/localtime"
  arch-chroot ${ROOT_MOUNTPOINT} ln -sf /usr/share/zoneinfo/${TIMEZONE} /etc/localtime &> /dev/null & PID=$!; _progress $PID
  _print_action "Executando" "hwclock --systohc --${HWCLOCK,,}"
  arch-chroot ${ROOT_MOUNTPOINT} hwclock --systohc --${HWCLOCK,,} &> /dev/null & PID=$!; _progress $PID
  _pause_function
}

_set_locale() {
  _print_title "CONFIGURANDO O LOCALE"
  echo
  _print_item "Locale" "${LOCALE}"
  _print_item "Keymap" "${KAYMAP}"
  echo
  sed -i "s/#\(${LOCALE}\)/\1/" ${ROOT_MOUNTPOINT}/etc/locale.gen
  _print_action "Executando" "locale-gen"
  arch-chroot ${ROOT_MOUNTPOINT} locale-gen &> /dev/null & PID=$!; _progress $PID
  _print_action "Executando" "echo \"LANG=${LOCALE}.UTF-8\" > /etc/locale.conf"
  echo -e "LANG=${LOCALE}.UTF-8" > "${ROOT_MOUNTPOINT}"/etc/locale.conf & PID=$!; _progress $PID
  _print_action "Running" "echo \"KEYMAP=${KAYMAP}\" > /etc/vconsole.conf"
  echo -e "KEYMAP=${KAYMAP}" > "${ROOT_MOUNTPOINT}"/etc/vconsole.conf & PID=$!; _progress $PID
  _pause_function
}

_set_network() {
  _print_title "CONFIGURANDO A REDE"
  echo
  HOSTNAME=$(echo "${HOSTNAME}" | tr '[:upper:]' '[:lower:]')
  _print_action "Definindo" "hostname"
  echo "${HOSTNAME}" > ${ROOT_MOUNTPOINT}/etc/hostname & PID=$!; _progress $PID
  _print_action "Configurando" "arquivo hosts"
  echo -e "127.0.0.1 localhost.localdomain localhost" > ${ROOT_MOUNTPOINT}/etc/hosts
  echo -e "::1 localhost.localdomain localhost" >> ${ROOT_MOUNTPOINT}/etc/hosts
  echo -e "127.0.1.1 ${HOSTNAME}.localdomain ${HOSTNAME}" >> ${ROOT_MOUNTPOINT}/etc/hosts & PID=$!; _progress $PID
  _pause_function
}

_generate_mkinitcpio() {
  local title="GERANDO O INITRAMFS"
  _print_title ${title}
  [[ $LUKS -eq 1 ]] && sed -i '/^HOOK/s/modconf block filesystems keyboard/keyboard keymap modconf block encrypt filesystems/' "${ROOT_MOUNTPOINT}"/etc/mkinitcpio.conf
  echo
  _read_input_option "Editar mkinitcpio.conf? [s/N]: "
  if [[ ${OPTION,,} == "s" ]]; then
    nano ${ROOT_MOUNTPOINT}/etc/mkinitcpio.conf
  fi
  _print_title ${title}
  echo
  arch-chroot ${ROOT_MOUNTPOINT} mkinitcpio -P
  _pause_function
}

_set_bootloader() {
  _print_title "BOOTLOADER"
  _print_item "Bootloader" "${BOOTLOADER}"
  case "${BOOTLOADER}" in
    "Grub")
      _print_subtitle "Instalando pacotes"
      _pacstrap_install "grub grub-btrfs efibootmgr"
      echo
      _read_input_option "Habilitar os-prober? [s/N]: "
      if [[ ${OPTION,,} == "s" ]]; then
        echo
        _pacstrap_install "os-prober"
      fi
      if [[ $LUKS -eq 1 ]]; then
        sed -i -e "s/GRUB_CMDLINE_LINUX=\"\"/GRUB_CMDLINE_LINUX=\"cryptdevice=UUID=${ROOT_UUID}:${CRYPT_NAME} root=\/dev\/mapper\/${CRYPT_NAME} rootflags=subvol=@ rw\"/g" ${ROOT_MOUNTPOINT}/etc/default/grub
      fi
      _print_subtitle "Grub install"
      arch-chroot ${ROOT_MOUNTPOINT} grub-install --target=x86_64-efi --efi-directory=${EFI_MOUNTPOINT} --bootloader-id="${BOOTLOADER_NAME}" --recheck
      _print_subtitle "Grub configuration file"
      arch-chroot ${ROOT_MOUNTPOINT} grub-mkconfig -o /boot/grub/grub.cfg
      _pause_function
      ;;
    "Systemd-boot")
      _print_subtitle "Configurando systemd-boot"
      arch-chroot "${ROOT_MOUNTPOINT}" bootctl --path="${EFI_MOUNTPOINT}" install
      if [[ $LUKS -eq 1 ]]; then
        {
          echo -e "title\t${BOOTLOADER_NAME}\nlinux\t/vmlinuz-${KERNEL_VERSION}"
          if [[ ! "${MICROCODE_VERSION}" = "" ]]; then
            echo -e "initrd\t/${MICROCODE_VERSION}.img"
          fi
          echo -e "initrd\t/initramfs-${KERNEL_VERSION}.img"
          echo -e "options\tcryptdevice=UUID=${ROOT_UUID}:${CRYPT_NAME} root=/dev/mapper/${CRYPT_NAME} rootflags=subvol=@ rw"
        } >> "${ROOT_MOUNTPOINT}""${EFI_MOUNTPOINT}"/loader/entries/arch.conf
      else
        {
          echo -e "title\t${BOOTLOADER_NAME}\nlinux\t/vmlinuz-${KERNEL_VERSION}"
          if [[ ! "${MICROCODE_VERSION}" = "None" ]]; then
            echo -e "initrd\t/${MICROCODE_VERSION}.img"
          fi
          echo -e "initrd\t/initramfs-${KERNEL_VERSION}.img"
          echo -e "options\troot=UUID=${ROOT_UUID} rootflags=subvol=@ rw"
        } >> "${ROOT_MOUNTPOINT}""${EFI_MOUNTPOINT}"/loader/entries/arch.conf
      fi
      echo -e "default  arch\ntimeout  3" > "${ROOT_MOUNTPOINT}""${EFI_MOUNTPOINT}"/loader/loader.conf
      _pause_function
      nano "${ROOT_MOUNTPOINT}""${EFI_MOUNTPOINT}"/loader/entries/arch.conf
      nano "${ROOT_MOUNTPOINT}""${EFI_MOUNTPOINT}"/loader/loader.conf
      ;;
    *)
      echo
      _print_info "Nenhum bootloader configurado!"
      _pause_function
      ;;
  esac
}

_set_root_passwd() {
  local title="SENHA DE ROOT"
  _print_title ${title}
  local PASSWD_CHECK=0
  echo
  arch-chroot ${ROOT_MOUNTPOINT} passwd && PASSWD_CHECK=1;
  while [[ $PASSWD_CHECK == 0 ]]; do
    _print_title ${title}
    echo
    _print_warning "A senha não é a mesma, tente novamente!"
    echo
    arch-chroot ${ROOT_MOUNTPOINT} passwd && PASSWD_CHECK=1;
  done
  _pause_function
}

_install_finish() {
  _print_title "INSTALAÇÃO COMPLETA"
  echo
  _print_item "Disco" "${INSTALL_DISK}"
  _print_item "Partição raiz" "${ROOT_PARTITION}"
  if [[ $LUKS -eq 1 ]]; then
    _print_item "Criptografia do disco" "${BGREEN}Sim${RESET}"
  else
    _print_item "Criptografia do disco" "${BRED}Não${RESET}"
  fi
  _print_item "Partição EFI" "${EFI_PARTITION}"
  _print_item "Versão do Kernel" "${KERNEL_VERSION}"
  _print_item "Versão do Microcode" "${MICROCODE_VERSION}"
  _print_item "Timezone" "${ZONE}/${SUBZONE}"
  _print_item "Relógio do Hardware" "${CLOCK_CHOICE}"
  _print_item "Locale" "${LOCALE}"
  _print_item "Keymap" "${KAYMAP}"
  _print_item "Hostname" "${NEW_HOSTNAME}"
  _print_item "Bootloader" "${BOOTLOADER}"
  echo
  _print_line
  _read_input_option "${BRED}Reboot system now? [y/N]: ${RESET}"
  if [[ ${OPTION,,} == "y" ]]; then
    clear
    setfont
    reboot now
  else
    setfont
    clear
    _print_exit
    exit 0
  fi
}
